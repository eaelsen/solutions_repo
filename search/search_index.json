{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \ud83c\udfaf Problem 1: Investigating the Range as a Function of the Angle of Projection \ud83d\udd0d Motivation Projectile motion offers a rich opportunity to explore fundamental physics. Understanding how range varies with angle helps explain trajectories in sports, engineering, and even space exploration. 1. \ud83d\udcd8 Theoretical Foundation We begin with the kinematic equations of motion: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated): $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ To find range \\(R\\) , solve for time of flight \\(T\\) when \\(y(T) = 0\\) : \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Substitute into \\(x(T)\\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This shows range depends on the sine of double the angle. Peak range occurs at \\(\\theta = 45^\\circ\\) . \ud83d\udd04 Family of Solutions Different values of: \\(v_0\\) : initial velocity \\(g\\) : gravitational acceleration \\(\\theta\\) : launch angle ... yield different trajectories and ranges. 2. \ud83d\udcca Analysis of the Range Let\u2019s examine the effect of: Angle: \\(\\theta\\) in [0\u00b0, 90\u00b0] \\(v_0 =\\) constant values \\(g = 9.81\\,m/s^2\\) We'll plot \\(R(\\theta)\\) for different \\(v_0\\) . 3. \ud83c\udf0d Practical Applications Uneven terrain: introduces asymmetric time of flight. Air resistance: breaks ideal symmetry; reduces range. Launch height \u2260 0: requires full quadratic solution for \\(y(t) = 0\\) 4. \ud83d\udcbb Implementation (Python Code) import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s\u00b2 angles = np.linspace(0, 90, 500) # degrees angles_rad = np.radians(angles) # Test different velocities velocities = [10, 20, 30] # m/s plt.figure(figsize=(10, 6)) for v0 in velocities: R = (v0 ** 2) * np.sin(2 * angles_rad) / g plt.plot(angles, R, label=f'v0 = {v0} m/s') plt.title(\"Projectile Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.legend() plt.grid(True) plt.show() \ud83d\udcc8 Graphical Insights The graphs will show: Symmetric curve peaking at 45\u00b0 Higher initial velocity \u2192 longer range Sensitivity to angle increases with speed \u26a0\ufe0f Limitations and Real-World Factors Air drag : can reduce range significantly Launch height : modifies time of flight Wind and spin : introduce lift or drag effects Non-constant gravity (e.g., rocket dynamics) \ud83d\udca1 Future Improvements Include drag force: \\(F_d = -kv^2\\) Vary \\(g\\) (e.g., Moon, Mars simulations) Add terrain modeling","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83c\udfaf Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion offers a rich opportunity to explore fundamental physics. Understanding how range varies with angle helps explain trajectories in sports, engineering, and even space exploration.","title":"\ud83d\udd0d Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"We begin with the kinematic equations of motion: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated): $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ To find range \\(R\\) , solve for time of flight \\(T\\) when \\(y(T) = 0\\) : \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Substitute into \\(x(T)\\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This shows range depends on the sine of double the angle. Peak range occurs at \\(\\theta = 45^\\circ\\) .","title":"1. \ud83d\udcd8 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Different values of: \\(v_0\\) : initial velocity \\(g\\) : gravitational acceleration \\(\\theta\\) : launch angle ... yield different trajectories and ranges.","title":"\ud83d\udd04 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Let\u2019s examine the effect of: Angle: \\(\\theta\\) in [0\u00b0, 90\u00b0] \\(v_0 =\\) constant values \\(g = 9.81\\,m/s^2\\) We'll plot \\(R(\\theta)\\) for different \\(v_0\\) .","title":"2. \ud83d\udcca Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Uneven terrain: introduces asymmetric time of flight. Air resistance: breaks ideal symmetry; reduces range. Launch height \u2260 0: requires full quadratic solution for \\(y(t) = 0\\)","title":"3. \ud83c\udf0d Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s\u00b2 angles = np.linspace(0, 90, 500) # degrees angles_rad = np.radians(angles) # Test different velocities velocities = [10, 20, 30] # m/s plt.figure(figsize=(10, 6)) for v0 in velocities: R = (v0 ** 2) * np.sin(2 * angles_rad) / g plt.plot(angles, R, label=f'v0 = {v0} m/s') plt.title(\"Projectile Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.legend() plt.grid(True) plt.show()","title":"4. \ud83d\udcbb Implementation (Python Code)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-insights","text":"The graphs will show: Symmetric curve peaking at 45\u00b0 Higher initial velocity \u2192 longer range Sensitivity to angle increases with speed","title":"\ud83d\udcc8 Graphical Insights"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-real-world-factors","text":"Air drag : can reduce range significantly Launch height : modifies time of flight Wind and spin : introduce lift or drag effects Non-constant gravity (e.g., rocket dynamics)","title":"\u26a0\ufe0f Limitations and Real-World Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#future-improvements","text":"Include drag force: \\(F_d = -kv^2\\) Vary \\(g\\) (e.g., Moon, Mars simulations) Add terrain modeling","title":"\ud83d\udca1 Future Improvements"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83c\udf00 Problem 2: Investigating the Dynamics of a Forced Damped Pendulum \ud83e\udded Motivation The forced damped pendulum showcases the interplay between damping, restoring forces, and external driving. It offers insight into linear vs. nonlinear behavior, including resonance and chaotic dynamics\u2014key phenomena in real-world systems like circuits, bridges, and biomechanics. 1. \ud83d\udcd8 Theoretical Foundation General Equation of Motion: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: \\(\\theta\\) : angular displacement \\(\\gamma\\) : damping coefficient \\(\\omega_0\\) : natural frequency \\((\\sqrt{g/L})\\) \\(A\\) : amplitude of the external force \\(\\omega\\) : driving frequency Small-Angle Approximation: For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , giving: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a linear second-order ODE with periodic forcing. Solutions can exhibit: Underdamping Resonance (when \\(\\omega \\approx \\omega_0\\) ) Steady-state oscillation 2. \ud83d\udcca Analysis of Dynamics We explore: Effects of increasing \\(\\gamma\\) : faster decay, less oscillation. Varying \\(A\\) : transition from linear to nonlinear behavior. Tuning \\(\\omega\\) : resonance effects and bifurcations. Chaos: Numerical solutions (no small-angle approx) show: Regular behavior (periodic or quasiperiodic) Chaotic behavior (sensitive dependence on initial conditions) 3. \ud83c\udf0d Practical Applications RLC circuits (analogous to the pendulum) Human gait dynamics Bridge design (e.g., Tacoma Narrows Bridge collapse) Energy harvesters using periodic mechanical motion 4. \ud83d\udcbb Implementation (Python Code) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters gamma = 0.2 # damping coefficient omega0 = 1.5 # natural frequency A = 1.2 # forcing amplitude omega_d = 2/3 # driving frequency def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 10000) # Solve ODE sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) # Plot plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.grid(True) plt.show() \ud83d\udd01 Phase Space and Poincar\u00e9 Section # Phase portrait plt.figure() plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title(\"Phase Space: \u03b8 vs \u03c9\") plt.xlabel(\"Theta\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.show() # Poincar\u00e9 section (sample once every drive period) T_drive = 2 * np.pi / omega_d indices = np.arange(int(T_drive / (t_eval[1]-t_eval[0])), len(t_eval), int(T_drive / (t_eval[1]-t_eval[0]))) plt.figure() plt.plot(sol.y[0][indices], sol.y[1][indices], 'o', markersize=1) plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.show() \ud83e\udde0 Discussion & Limitations Limitations: Small-angle approximation fails at large amplitudes. Ignores frictional forces with different damping profiles. Assumes perfectly periodic driving force. Extensions: Nonlinear damping: \\(\\propto |\\omega|\\omega\\) Stochastic or aperiodic driving force Double pendulum for richer chaos","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83c\udf00 Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum showcases the interplay between damping, restoring forces, and external driving. It offers insight into linear vs. nonlinear behavior, including resonance and chaotic dynamics\u2014key phenomena in real-world systems like circuits, bridges, and biomechanics.","title":"\ud83e\udded Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. \ud83d\udcd8 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-equation-of-motion","text":"\\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: \\(\\theta\\) : angular displacement \\(\\gamma\\) : damping coefficient \\(\\omega_0\\) : natural frequency \\((\\sqrt{g/L})\\) \\(A\\) : amplitude of the external force \\(\\omega\\) : driving frequency","title":"General Equation of Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , giving: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a linear second-order ODE with periodic forcing. Solutions can exhibit: Underdamping Resonance (when \\(\\omega \\approx \\omega_0\\) ) Steady-state oscillation","title":"Small-Angle Approximation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"We explore: Effects of increasing \\(\\gamma\\) : faster decay, less oscillation. Varying \\(A\\) : transition from linear to nonlinear behavior. Tuning \\(\\omega\\) : resonance effects and bifurcations.","title":"2. \ud83d\udcca Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos","text":"Numerical solutions (no small-angle approx) show: Regular behavior (periodic or quasiperiodic) Chaotic behavior (sensitive dependence on initial conditions)","title":"Chaos:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"RLC circuits (analogous to the pendulum) Human gait dynamics Bridge design (e.g., Tacoma Narrows Bridge collapse) Energy harvesters using periodic mechanical motion","title":"3. \ud83c\udf0d Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters gamma = 0.2 # damping coefficient omega0 = 1.5 # natural frequency A = 1.2 # forcing amplitude omega_d = 2/3 # driving frequency def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 10000) # Solve ODE sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) # Plot plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.grid(True) plt.show()","title":"4. \ud83d\udcbb Implementation (Python Code)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-space-and-poincare-section","text":"# Phase portrait plt.figure() plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title(\"Phase Space: \u03b8 vs \u03c9\") plt.xlabel(\"Theta\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.show() # Poincar\u00e9 section (sample once every drive period) T_drive = 2 * np.pi / omega_d indices = np.arange(int(T_drive / (t_eval[1]-t_eval[0])), len(t_eval), int(T_drive / (t_eval[1]-t_eval[0]))) plt.figure() plt.plot(sol.y[0][indices], sol.y[1][indices], 'o', markersize=1) plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.show()","title":"\ud83d\udd01 Phase Space and Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#discussion-limitations","text":"","title":"\ud83e\udde0 Discussion &amp; Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"Small-angle approximation fails at large amplitudes. Ignores frictional forces with different damping profiles. Assumes perfectly periodic driving force.","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"Nonlinear damping: \\(\\propto |\\omega|\\omega\\) Stochastic or aperiodic driving force Double pendulum for richer chaos","title":"Extensions:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83c\udf0d Problem 1: Orbital Period and Orbital Radius \ud83d\ude80 Motivation Kepler\u2019s Third Law reveals a deep connection between time and space in orbital mechanics: the square of a planet's orbital period is proportional to the cube of its orbital radius. This law forms a bridge between observation and Newtonian gravitation, enabling predictions of satellite behavior, moon motion, and planetary distances. 1. \ud83d\udcd8 Theoretical Foundation Newton\u2019s Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Centripetal Force for Circular Motion: \\[ F = \\frac{mv^2}{r} \\] Equating the two: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] \\[ v = \\sqrt{\\frac{GM}{r}} \\] Period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} = 2\\pi r \\sqrt{\\frac{r}{GM}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Final Form of Kepler's Third Law: \\[ T^2 \\propto r^3 \\] 2. \ud83e\udde0 Implications for Astronomy Allows estimation of planetary masses and orbital distances . Explains consistent behavior across moons, planets, and satellites. Groundwork for Newton\u2019s universal law of gravitation. 3. \ud83c\udf0d Real-World Examples Example 1: The Moon around Earth Radius: \\(r \\approx 384,400\\) km Period: \\(T \\approx 27.3\\) days Use to verify \\(T^2 \\propto r^3\\) Example 2: Planets in the Solar System Compare \\(\\frac{T^2}{r^3}\\) across planets\u2014should be nearly constant. 4. \ud83d\udcbb Python Simulation and Verification import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 1.989e30 # mass of the Sun (kg) # Orbital radii (m) and periods (s) of planets planet_data = { 'Mercury': (5.79e10, 7.60e6), 'Venus': (1.08e11, 1.94e7), 'Earth': (1.50e11, 3.15e7), 'Mars': (2.28e11, 5.94e7), 'Jupiter': (7.78e11, 3.74e8), 'Saturn': (1.43e12, 9.29e8) } # Calculate T^2 and R^3 radii = [] t_squared = [] r_cubed = [] for planet, (r, T) in planet_data.items(): radii.append(r) t_squared.append(T**2) r_cubed.append(r**3) # Plot plt.figure(figsize=(8, 6)) plt.loglog(r_cubed, t_squared, 'o-') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.show() \ud83d\udcc8 Visualization Log-log plot of \\(T^2\\) vs \\(r^3\\) should yield a straight line. Confirms that \\(T^2 \\propto r^3\\) for all major planets. \ud83d\udcc9 Beyond Circular Orbits For elliptical orbits, Kepler\u2019s Third Law still holds with: $$ T^2 = \\frac{4\\pi^2 a^3}{GM} $$ where \\(a\\) is the semi-major axis. * Used in binary star systems, exoplanets, and orbital transfer calculations.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"\ud83c\udf0d Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law reveals a deep connection between time and space in orbital mechanics: the square of a planet's orbital period is proportional to the cube of its orbital radius. This law forms a bridge between observation and Newtonian gravitation, enabling predictions of satellite behavior, moon motion, and planetary distances.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. \ud83d\udcd8 Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-gravitation","text":"\\[ F = \\frac{GMm}{r^2} \\]","title":"Newton\u2019s Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force-for-circular-motion","text":"\\[ F = \\frac{mv^2}{r} \\] Equating the two: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] \\[ v = \\sqrt{\\frac{GM}{r}} \\] Period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} = 2\\pi r \\sqrt{\\frac{r}{GM}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\]","title":"Centripetal Force for Circular Motion:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-form-of-keplers-third-law","text":"\\[ T^2 \\propto r^3 \\]","title":"Final Form of Kepler's Third Law:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Allows estimation of planetary masses and orbital distances . Explains consistent behavior across moons, planets, and satellites. Groundwork for Newton\u2019s universal law of gravitation.","title":"2. \ud83e\udde0 Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. \ud83c\udf0d Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon-around-earth","text":"Radius: \\(r \\approx 384,400\\) km Period: \\(T \\approx 27.3\\) days Use to verify \\(T^2 \\propto r^3\\)","title":"Example 1: The Moon around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-in-the-solar-system","text":"Compare \\(\\frac{T^2}{r^3}\\) across planets\u2014should be nearly constant.","title":"Example 2: Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-and-verification","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 1.989e30 # mass of the Sun (kg) # Orbital radii (m) and periods (s) of planets planet_data = { 'Mercury': (5.79e10, 7.60e6), 'Venus': (1.08e11, 1.94e7), 'Earth': (1.50e11, 3.15e7), 'Mars': (2.28e11, 5.94e7), 'Jupiter': (7.78e11, 3.74e8), 'Saturn': (1.43e12, 9.29e8) } # Calculate T^2 and R^3 radii = [] t_squared = [] r_cubed = [] for planet, (r, T) in planet_data.items(): radii.append(r) t_squared.append(T**2) r_cubed.append(r**3) # Plot plt.figure(figsize=(8, 6)) plt.loglog(r_cubed, t_squared, 'o-') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.show()","title":"4. \ud83d\udcbb Python Simulation and Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualization","text":"Log-log plot of \\(T^2\\) vs \\(r^3\\) should yield a straight line. Confirms that \\(T^2 \\propto r^3\\) for all major planets.","title":"\ud83d\udcc8 Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#beyond-circular-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law still holds with: $$ T^2 = \\frac{4\\pi^2 a^3}{GM} $$ where \\(a\\) is the semi-major axis. * Used in binary star systems, exoplanets, and orbital transfer calculations.","title":"\ud83d\udcc9 Beyond Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 \ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities \ud83d\udd2d Motivation Escape and cosmic velocities determine the energy required for a spacecraft to orbit Earth, break free from Earth's gravity, or leave the Solar System. These concepts are fundamental to modern astronautics, including satellite launches, Mars missions, and future interstellar travel. 1. \ud83d\udcd8 Definitions and Physical Meaning First Cosmic Velocity (v\u2081): Minimum velocity required to maintain a circular orbit around a planet (orbital speed). $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (v\u2082): Minimum velocity to escape the gravitational field of a celestial body (escape velocity). $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity (v\u2083): Minimum velocity required to escape the Solar System from Earth's orbit (relative to the Sun). $$ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{R_{\\text{earth-orbit}}}} \\approx 42.1\\,\\text{km/s} $$ 2. \ud83e\uddee Derivations Derived from conservation of energy : Kinetic energy vs. gravitational potential energy Escape when total mechanical energy \u2265 0 \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{R} \\] 3. \ud83c\udf0d Example: Earth, Mars, Jupiter Planet Radius (m) Mass (kg) Earth 6.371 \u00d7 10\u2076 5.972 \u00d7 10\u00b2\u2074 Mars 3.390 \u00d7 10\u2076 6.417 \u00d7 10\u00b2\u00b3 Jupiter 6.9911 \u00d7 10\u2077 1.898 \u00d7 10\u00b2\u2077 4. \ud83d\udcbb Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3/kg/s\u00b2 # Celestial body data bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.972e24}, \"Mars\": {\"R\": 3.390e6, \"M\": 6.417e23}, \"Jupiter\": {\"R\": 6.9911e7, \"M\": 1.898e27} } # Calculate cosmic velocities results = {} for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[body] = {\"v1\": v1, \"v2\": v2} # Plotting labels = list(results.keys()) v1_values = [results[b][\"v1\"] / 1000 for b in labels] # in km/s v2_values = [results[b][\"v2\"] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_values, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_values, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, Jupiter\") plt.legend() plt.grid(True) plt.show() \ud83d\udcc8 Visualization Bar chart comparing first and second cosmic velocities. Demonstrates how planetary mass and radius influence escape speed. \ud83c\udf0c Importance in Space Exploration 1st Cosmic Velocity : Launching satellites into stable orbits. 2nd Cosmic Velocity : Interplanetary missions (e.g., Mars rover). 3rd Cosmic Velocity : Escape Solar System (e.g., Voyager 1/2). \ud83d\udd01 Extensions Include atmospheric drag for realistic models. Account for rotation (reduces required launch speed at equator). Compare with rocket equation : \\(\\Delta v = v_e \\ln(m_0/m_f)\\)","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"\ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape and cosmic velocities determine the energy required for a spacecraft to orbit Earth, break free from Earth's gravity, or leave the Solar System. These concepts are fundamental to modern astronautics, including satellite launches, Mars missions, and future interstellar travel.","title":"\ud83d\udd2d Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-and-physical-meaning","text":"First Cosmic Velocity (v\u2081): Minimum velocity required to maintain a circular orbit around a planet (orbital speed). $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (v\u2082): Minimum velocity to escape the gravitational field of a celestial body (escape velocity). $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity (v\u2083): Minimum velocity required to escape the Solar System from Earth's orbit (relative to the Sun). $$ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{R_{\\text{earth-orbit}}}} \\approx 42.1\\,\\text{km/s} $$","title":"1. \ud83d\udcd8 Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivations","text":"Derived from conservation of energy : Kinetic energy vs. gravitational potential energy Escape when total mechanical energy \u2265 0 \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{R} \\]","title":"2. \ud83e\uddee Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-example-earth-mars-jupiter","text":"Planet Radius (m) Mass (kg) Earth 6.371 \u00d7 10\u2076 5.972 \u00d7 10\u00b2\u2074 Mars 3.390 \u00d7 10\u2076 6.417 \u00d7 10\u00b2\u00b3 Jupiter 6.9911 \u00d7 10\u2077 1.898 \u00d7 10\u00b2\u2077","title":"3. \ud83c\udf0d Example: Earth, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3/kg/s\u00b2 # Celestial body data bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.972e24}, \"Mars\": {\"R\": 3.390e6, \"M\": 6.417e23}, \"Jupiter\": {\"R\": 6.9911e7, \"M\": 1.898e27} } # Calculate cosmic velocities results = {} for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[body] = {\"v1\": v1, \"v2\": v2} # Plotting labels = list(results.keys()) v1_values = [results[b][\"v1\"] / 1000 for b in labels] # in km/s v2_values = [results[b][\"v2\"] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_values, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_values, width, label='2nd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, Jupiter\") plt.legend() plt.grid(True) plt.show()","title":"4. \ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization","text":"Bar chart comparing first and second cosmic velocities. Demonstrates how planetary mass and radius influence escape speed.","title":"\ud83d\udcc8 Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"1st Cosmic Velocity : Launching satellites into stable orbits. 2nd Cosmic Velocity : Interplanetary missions (e.g., Mars rover). 3rd Cosmic Velocity : Escape Solar System (e.g., Voyager 1/2).","title":"\ud83c\udf0c Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#extensions","text":"Include atmospheric drag for realistic models. Account for rotation (reduces required launch speed at equator). Compare with rocket equation : \\(\\Delta v = v_e \\ln(m_0/m_f)\\)","title":"\ud83d\udd01 Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf0c Problem 3: Trajectories of a Freely Released Payload Near Earth \ud83d\ude80 Motivation Understanding the motion of a payload released from a moving spacecraft is critical for mission design\u2014whether for orbit insertion, satellite deployment, or Earth reentry. This problem blends Newtonian gravity, Keplerian orbits, and numerical simulations. 1. \ud83d\udcd8 Theoretical Foundation Orbital Trajectories: Depending on total mechanical energy \\(E\\) , a released payload may follow: Elliptical orbit ( \\(E < 0\\) ) Parabolic escape ( \\(E = 0\\) ) Hyperbolic escape ( \\(E > 0\\) ) Use: \\[ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\] And angular momentum conservation to derive trajectory type. 2. \ud83d\udcbb Simulation Overview We'll simulate the trajectory using Newton's gravitational force: \\[ \\vec{F} = -\\frac{GMm}{r^3}\\vec{r} \\] Use the Runge-Kutta or Velocity Verlet method to update: Position \\(\\vec{r}\\) Velocity \\(\\vec{v}\\) Inputs: Initial position \\(\\vec{r}_0\\) Initial velocity \\(\\vec{v}_0\\) Altitude, direction, and speed 3. \ud83e\udde0 Physical Interpretations Orbital Insertion : Initial \\(v\\) < escape velocity, tangential direction. Reentry : Suborbital trajectory intersecting Earth. Escape : \\(v > v_{escape}\\) , hyperbolic path. 4. \ud83d\udcbb Python Implementation Outline import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 # Earth mass R_earth = 6.371e6 # Earth radius def gravity(r): r_mag = np.linalg.norm(r) return -G * M * r / r_mag**3 # Initial conditions altitude = 400e3 # 400 km above surface r0 = np.array([R_earth + altitude, 0]) v0 = np.array([0, 7500]) # initial speed in m/s # Simulation dt = 1 # time step (s) t_max = 6000 steps = int(t_max / dt) r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): a = gravity(r[i]) v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i+1] * dt # Plot trajectory plt.figure(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_patch(earth) plt.plot(r[:, 0], r[:, 1]) plt.axis('equal') plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid(True) plt.show() \ud83d\udcc8 Visualizations Orbit trajectory (2D path) Overlay Earth as a circle Show variations for different velocities: orbital, suborbital, escape \ud83e\udde0 Insights and Applications Simulate satellite deployment Predict crash or reentry scenarios Model escape trajectories for Moon or Mars missions","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83c\udf0c Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"Understanding the motion of a payload released from a moving spacecraft is critical for mission design\u2014whether for orbit insertion, satellite deployment, or Earth reentry. This problem blends Newtonian gravity, Keplerian orbits, and numerical simulations.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","text":"","title":"1. \ud83d\udcd8 Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-trajectories","text":"Depending on total mechanical energy \\(E\\) , a released payload may follow: Elliptical orbit ( \\(E < 0\\) ) Parabolic escape ( \\(E = 0\\) ) Hyperbolic escape ( \\(E > 0\\) ) Use: \\[ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\] And angular momentum conservation to derive trajectory type.","title":"Orbital Trajectories:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-simulation-overview","text":"We'll simulate the trajectory using Newton's gravitational force: \\[ \\vec{F} = -\\frac{GMm}{r^3}\\vec{r} \\] Use the Runge-Kutta or Velocity Verlet method to update: Position \\(\\vec{r}\\) Velocity \\(\\vec{v}\\)","title":"2. \ud83d\udcbb Simulation Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#inputs","text":"Initial position \\(\\vec{r}_0\\) Initial velocity \\(\\vec{v}_0\\) Altitude, direction, and speed","title":"Inputs:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-physical-interpretations","text":"Orbital Insertion : Initial \\(v\\) < escape velocity, tangential direction. Reentry : Suborbital trajectory intersecting Earth. Escape : \\(v > v_{escape}\\) , hyperbolic path.","title":"3. \ud83e\udde0 Physical Interpretations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-python-implementation-outline","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 # Earth mass R_earth = 6.371e6 # Earth radius def gravity(r): r_mag = np.linalg.norm(r) return -G * M * r / r_mag**3 # Initial conditions altitude = 400e3 # 400 km above surface r0 = np.array([R_earth + altitude, 0]) v0 = np.array([0, 7500]) # initial speed in m/s # Simulation dt = 1 # time step (s) t_max = 6000 steps = int(t_max / dt) r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): a = gravity(r[i]) v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i+1] * dt # Plot trajectory plt.figure(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_patch(earth) plt.plot(r[:, 0], r[:, 1]) plt.axis('equal') plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid(True) plt.show()","title":"4. \ud83d\udcbb Python Implementation Outline"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualizations","text":"Orbit trajectory (2D path) Overlay Earth as a circle Show variations for different velocities: orbital, suborbital, escape","title":"\ud83d\udcc8 Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#insights-and-applications","text":"Simulate satellite deployment Predict crash or reentry scenarios Model escape trajectories for Moon or Mars missions","title":"\ud83e\udde0 Insights and Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Interference Patterns on a Water Surface \ud83c\udfaf Goal To analyze how water surface interference patterns form when waves from multiple point sources (e.g., placed at the vertices of a regular polygon) overlap. The project explores constructive and destructive interference through superposition. \ud83e\uddee Wave Equation for a Single Source \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) \\(k = \\frac{2\\pi}{\\lambda}\\) , \\(\\omega = 2\\pi f\\) \ud83d\udd04 Superposition of Multiple Sources \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Sources are placed at polygon vertices (e.g., triangle, square, pentagon). \ud83e\uddea Project Steps Choose a Polygon (e.g., equilateral triangle) Position the Sources at each vertex Construct Wave Equations for each source Superpose to get total displacement Visualize the resulting pattern (at fixed time) Analyze areas of constructive vs destructive interference \ud83d\udcbb Python Implementation Concept You can use Python with numpy and matplotlib : import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 \u03bb = 1 k = 2 * np.pi / \u03bb f = 1 \u03c9 = 2 * np.pi * f t = 0 # Source positions (equilateral triangle for example) sources = [(0, 1), (-np.sqrt(3)/2, -0.5), (np.sqrt(3)/2, -0.5)] # Grid x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) eta_total = np.zeros_like(X) # Superposition for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_total += (A / np.sqrt(r + 1e-6)) * np.cos(k * r - \u03c9 * t) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label=\"Wave Displacement\") plt.title(\"Interference Pattern on Water Surface\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.show() \ud83d\udcc8 Deliverables \ud83d\udcc4 Markdown report or Jupyter notebook \ud83d\udcca Visuals of wave patterns for different polygons \ud83d\udd0d Analysis of interference zones","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#goal","text":"To analyze how water surface interference patterns form when waves from multiple point sources (e.g., placed at the vertices of a regular polygon) overlap. The project explores constructive and destructive interference through superposition.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation-for-a-single-source","text":"\\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) \\(k = \\frac{2\\pi}{\\lambda}\\) , \\(\\omega = 2\\pi f\\)","title":"\ud83e\uddee Wave Equation for a Single Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-multiple-sources","text":"\\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Sources are placed at polygon vertices (e.g., triangle, square, pentagon).","title":"\ud83d\udd04 Superposition of Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#project-steps","text":"Choose a Polygon (e.g., equilateral triangle) Position the Sources at each vertex Construct Wave Equations for each source Superpose to get total displacement Visualize the resulting pattern (at fixed time) Analyze areas of constructive vs destructive interference","title":"\ud83e\uddea Project Steps"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-implementation-concept","text":"You can use Python with numpy and matplotlib : import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 \u03bb = 1 k = 2 * np.pi / \u03bb f = 1 \u03c9 = 2 * np.pi * f t = 0 # Source positions (equilateral triangle for example) sources = [(0, 1), (-np.sqrt(3)/2, -0.5), (np.sqrt(3)/2, -0.5)] # Grid x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) eta_total = np.zeros_like(X) # Superposition for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_total += (A / np.sqrt(r + 1e-6)) * np.cos(k * r - \u03c9 * t) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label=\"Wave Displacement\") plt.title(\"Interference Pattern on Water Surface\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.show()","title":"\ud83d\udcbb Python Implementation Concept"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"\ud83d\udcc4 Markdown report or Jupyter notebook \ud83d\udcca Visuals of wave patterns for different polygons \ud83d\udd0d Analysis of interference zones","title":"\ud83d\udcc8 Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u269b\ufe0f Problem: Simulating the Effects of the Lorentz Force \ud83e\uddf2 Motivation The Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] governs charged particle motion in electric and magnetic fields. Simulating this helps visualize behavior in devices like cyclotrons, mass spectrometers, and magnetic traps. \ud83d\udd2c Project Tasks 1. Exploration of Applications Particle accelerators, fusion devices, astrophysics Understand the roles of electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields 2. Simulating Particle Motion Scenarios: Uniform magnetic field Uniform electric field Crossed \\(\\vec{E}\\) and \\(\\vec{B}\\) fields Solve Newton's second law using: Euler or Runge-Kutta methods 3. Parameter Exploration Vary: Field strengths Initial velocity Charge-to-mass ratio ( \\(q/m\\) ) Observe effects on path shape, radius, and drift 4. Visualization 2D/3D trajectory plots Identify: Circular motion (Larmor radius) Helical paths E\u00d7B drift \ud83d\udcbb Suggested Tools numpy : Numerical calculations matplotlib : Plotting scipy.integrate.solve_ivp : RK solver for motion \ud83d\udce4 Deliverables Markdown or Jupyter Notebook with: Code Simulated paths Visuals of field configurations Discussion on real-world applications Optional: Extend to non-uniform fields or relativistic corrections","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-simulating-the-effects-of-the-lorentz-force","text":"","title":"\u269b\ufe0f Problem: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] governs charged particle motion in electric and magnetic fields. Simulating this helps visualize behavior in devices like cyclotrons, mass spectrometers, and magnetic traps.","title":"\ud83e\uddf2 Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#project-tasks","text":"","title":"\ud83d\udd2c Project Tasks"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Particle accelerators, fusion devices, astrophysics Understand the roles of electric ( \\(\\vec{E}\\) ) and magnetic ( \\(\\vec{B}\\) ) fields","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"Scenarios: Uniform magnetic field Uniform electric field Crossed \\(\\vec{E}\\) and \\(\\vec{B}\\) fields Solve Newton's second law using: Euler or Runge-Kutta methods","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Vary: Field strengths Initial velocity Charge-to-mass ratio ( \\(q/m\\) ) Observe effects on path shape, radius, and drift","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"2D/3D trajectory plots Identify: Circular motion (Larmor radius) Helical paths E\u00d7B drift","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#suggested-tools","text":"numpy : Numerical calculations matplotlib : Plotting scipy.integrate.solve_ivp : RK solver for motion","title":"\ud83d\udcbb Suggested Tools"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"Markdown or Jupyter Notebook with: Code Simulated paths Visuals of field configurations Discussion on real-world applications Optional: Extend to non-uniform fields or relativistic corrections","title":"\ud83d\udce4 Deliverables"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \u26a1 Problem: Equivalent Resistance Using Graph Theory \ud83c\udfaf Motivation Graph theory provides a powerful way to model and solve complex resistor networks, especially when traditional series-parallel methods fall short. By modeling resistors as weighted edges and nodes as junctions, circuits can be simplified iteratively. \ud83e\udde0 Task Options Option 1 \u2013 Simplified Task (Algorithm Description) Describe an algorithm that: Identifies and reduces series and parallel connections Iteratively simplifies the graph Emphasize how nested combinations are resolved Option 2 \u2013 Advanced Task (Algorithm Implementation) Implement in Python (suggested using networkx ) Must handle: Input graphs Nested and mixed series-parallel configurations Output of final equivalent resistance Test Cases : Simple series/parallel resistors Nested circuits Graphs with multiple loops or cycles \ud83d\udcbb Suggested Python Libraries networkx : Graph modeling sympy : Symbolic simplification (optional) matplotlib : For visualizing the circuit \ud83d\udce4 Deliverables Pseudocode or full Python implementation Description of how complex networks are handled Analysis of performance, strengths, and limitations","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-equivalent-resistance-using-graph-theory","text":"","title":"\u26a1 Problem: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Graph theory provides a powerful way to model and solve complex resistor networks, especially when traditional series-parallel methods fall short. By modeling resistors as weighted edges and nodes as junctions, circuits can be simplified iteratively.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-options","text":"","title":"\ud83e\udde0 Task Options"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-1-simplified-task-algorithm-description","text":"Describe an algorithm that: Identifies and reduces series and parallel connections Iteratively simplifies the graph Emphasize how nested combinations are resolved","title":"Option 1 \u2013 Simplified Task (Algorithm Description)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-advanced-task-algorithm-implementation","text":"Implement in Python (suggested using networkx ) Must handle: Input graphs Nested and mixed series-parallel configurations Output of final equivalent resistance Test Cases : Simple series/parallel resistors Nested circuits Graphs with multiple loops or cycles","title":"Option 2 \u2013 Advanced Task (Algorithm Implementation)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#suggested-python-libraries","text":"networkx : Graph modeling sympy : Symbolic simplification (optional) matplotlib : For visualizing the circuit","title":"\ud83d\udcbb Suggested Python Libraries"},{"location":"1%20Physics/5%20Circuits/Problem_1/#deliverables","text":"Pseudocode or full Python implementation Description of how complex networks are handled Analysis of performance, strengths, and limitations","title":"\ud83d\udce4 Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}